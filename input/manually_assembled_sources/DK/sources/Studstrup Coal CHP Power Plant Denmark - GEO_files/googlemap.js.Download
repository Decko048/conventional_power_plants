/*This functions on this file can be broadly classified into three sections:
  1. General functions for showing placemark(used in all the transmission types).
  2. Functions for Polyline and Polygons.
  3. Encoding algorithm for encoding the coordinates or Polylines and polygons into strings. 
  */

window.geomapcont = null;
window.geolatelem = null;
window.geolngelem = null;
window.geocountry = null;
window.geostate = null;
window.geolatelemend = null;
window.geolngelemend = null;
window.geozoomlevel = 11;

COLORS = [["red", "#ff0000"], ["orange", "#ff8800"], ["green","#008000"],
       ["blue", "#000080"], ["purple", "#800080"]];
AI_Color = "#00FA9A";
var options = {};
var lineCounter_ = 0;
var shapeCount = 0;
var overlaysCount = -1;
var ai_overlaysCount = -1;
var markerCounter_ = 0;
var colorIndex_ = 0;
var featureTable_;
var map;
var linesJSON = new Array();
var shapesJSON = new Array();
var lineCount=0;
var poly;
var line = new Array();
var polygon = new Array();
var ai_polygon = new Array();
var savedPolygon = new Array();
var polyType;
var result;
var saveShapeCount=0;
var saveLineCount=0;
var savedMarker;
var savedMarker2;
var flag = false;
//----------------------------------------- Encoding the Coordinates as a String ----------------------------------------

//The constructor
PolylineEncoder = function(numLevels, zoomFactor, verySmall, forceEndpoints) {
    var i;
    if(!numLevels) {
        numLevels = 18;
    }
    if(!zoomFactor) {
        zoomFactor = 2;
    }
    if(!verySmall) {
        verySmall = 0.00001;
    }
    if(!forceEndpoints) {
        forceEndpoints = true;
    }
    this.numLevels = numLevels;
    this.zoomFactor = zoomFactor;
    this.verySmall = verySmall;
    this.forceEndpoints = forceEndpoints;
    this.zoomLevelBreaks = new Array(numLevels);
    for(i = 0; i < numLevels; i++) {
        this.zoomLevelBreaks[i] = verySmall*Math.pow(zoomFactor, numLevels-i-1);
    }
}

//The main function.  Essentially the Douglas-Peucker
//algorithm, adapted for encoding. Rather than simply
//eliminating points, we record their from the
//segment which occurs at that recursive step.  These
//distances are then easily converted to zoom levels.
PolylineEncoder.prototype.dpEncode = function(points) {
    var absMaxDist = 0;
    var stack = [];
    var dists = new Array(points.length);
    var maxDist, maxLoc, temp, first, last, current;
    var i, encodedPoints, encodedLevels;
    var segmentLength;

    if(points.length > 2) {
        stack.push([0, points.length-1]);
        while(stack.length > 0) {
            current = stack.pop();
            maxDist = 0;
            segmentLength = Math.pow(points[current[1]].lat()-points[current[0]].lat(),2) + 
                Math.pow(points[current[1]].lng()-points[current[0]].lng(),2);
            for(i = current[0]+1; i < current[1]; i++) {
                temp = this.distance(points[i], 
                        points[current[0]], points[current[1]],
                        segmentLength);
                if(temp > maxDist) {
                    maxDist = temp;
                    maxLoc = i;
                    if(maxDist > absMaxDist) {
                        absMaxDist = maxDist;
                    }
                }
            }
            if(maxDist > this.verySmall) {
                dists[maxLoc] = maxDist;
                stack.push([current[0], maxLoc]);
                stack.push([maxLoc, current[1]]);
            }
        }
    }

    encodedPoints = this.createEncodings(points, dists);
    encodedLevels = this.encodeLevels(points, dists, absMaxDist);
    return {
encodedPoints: encodedPoints,
                   encodedLevels: encodedLevels,
                   encodedPointsLiteral: encodedPoints.replace(/\\/g,"\\\\")
    }
}

PolylineEncoder.prototype.dpEncodeToJSON = function(points,
        color, weight, opacity) {
    if(!opacity) {
        opacity = 0.9;
    }
    if(!weight) {
        weight = 3;
    }
    if(!color) {
        color = "#0000ff";
    }
    result = this.dpEncode(points);
    return {
color: color,
           weight: weight,
           opacity: opacity,
           points: result.encodedPoints,
           levels: result.encodedLevels,
           numLevels: this.numLevels,
           zoomFactor: this.zoomFactor
    }
}

PolylineEncoder.prototype.dpEncodeToGPolyline = function(points,
        color, weight, opacity) {
    if(!opacity) {
        opacity = 0.9;
    }
    if(!weight) {
        weight = 3;
    }
    if(!color) {
        color = "#0000ff";
    }
    return new GPolyline.fromEncoded(
            this.dpEncodeToJSON(points, color, weight, opacity));
}

PolylineEncoder.prototype.dpEncodeToGPolygon = function(pointsArray,
        boundaryColor, boundaryWeight, boundaryOpacity,
        fillColor, fillOpacity, fill, outline) {
    var i, boundaries;
    if(!boundaryColor) {
        boundaryColor = "#0000ff";
    }
    if(!boundaryWeight) {
        boundaryWeight = 3;
    }
    if(!boundaryOpacity) {
        boundaryOpacity = 0.9;
    }
    if(!fillColor) {
        fillColor = boundaryColor;
    }
    if(!fillOpacity) {
        fillOpacity = boundaryOpacity/3;
    }
    if(fill==undefined) {
        fill = true;
    }
    if(outline==undefined) {
        outline = true;
    }

    boundaries = new Array(0);
    for(i=0; i<pointsArray.length; i++) {
        boundaries.push(this.dpEncodeToJSON(pointsArray[i],
                    boundaryColor, boundaryWeight, boundaryOpacity));
    }
    return new GPolygon.fromEncoded({
polylines: boundaries,
color: fillColor,
opacity: fillOpacity,
fill: fill,
outline: outline
});
}

//distance(p0, p1, p2) computes the distance between the point p0
//and the segment [p1,p2].  This could probably be replaced with
//something that is a bit more numerically stable.
PolylineEncoder.prototype.distance = function(p0, p1, p2, segLength) {
    var u, out;

    if(p1.lat() === p2.lat() && p1.lng() === p2.lng()) {
        out = Math.sqrt(Math.pow(p2.lat()-p0.lat(),2) + Math.pow(p2.lng()-p0.lng(),2));
    }
    else {
        u = ((p0.lat()-p1.lat())*(p2.lat()-p1.lat())+(p0.lng()-p1.lng())*(p2.lng()-p1.lng()))/
            segLength;

        if(u <= 0) {
            out = Math.sqrt(Math.pow(p0.lat() - p1.lat(),2) + Math.pow(p0.lng() - p1.lng(),2));
        }
        if(u >= 1) {
            out = Math.sqrt(Math.pow(p0.lat() - p2.lat(),2) + Math.pow(p0.lng() - p2.lng(),2));
        }
        if(0 < u && u < 1) {
            out = Math.sqrt(Math.pow(p0.lat()-p1.lat()-u*(p2.lat()-p1.lat()),2) +
                    Math.pow(p0.lng()-p1.lng()-u*(p2.lng()-p1.lng()),2));
        }
    }
    return out;
}

//The createEncodings function is very similar to Google's
//http://www.google.com/apis/maps/documentation/polyline.js
//The key difference is that not all points are encoded, 
//since some were eliminated by Douglas-Peucker.
PolylineEncoder.prototype.createEncodings = function(points, dists) {
    var i, dlat, dlng;
    var plat = 0;
    var plng = 0;
    var encoded_points = "";
    for(i = 0; i < points.length; i++) {
        if(dists[i] != undefined || i == 0 || i == points.length-1) {
            var point = points[i];
            var lat = point.lat();
            var lng = point.lng();
            var late5 = Math.floor(lat * 1e5);
            var lnge5 = Math.floor(lng * 1e5);
            dlat = late5 - plat;
            dlng = lnge5 - plng;
            plat = late5;
            plng = lnge5;
            encoded_points += this.encodeSignedNumber(dlat) + 
                this.encodeSignedNumber(dlng);
        }
    }
    return encoded_points;
}

//This computes the appropriate zoom level of a point in terms of it's 
//distance from the relevant segment in the DP algorithm.  Could be done
//in terms of a logarithm, but this approach makes it a bit easier to
//ensure that the level is not too large.
PolylineEncoder.prototype.computeLevel = function(dd) {
    var lev;
    if(dd > this.verySmall) {
        lev=0;
        while(dd < this.zoomLevelBreaks[lev]) {
            lev++;
        }
        return lev;
    }
}

//Now we can use the previous function to march down the list
//of points and encode the levels.  Like createEncodings, we
//ignore points whose distance (in dists) is undefined.
PolylineEncoder.prototype.encodeLevels = function(points, dists, absMaxDist) {
    var i;
    var encoded_levels = "";
    if(this.forceEndpoints) {
        encoded_levels += this.encodeNumber(this.numLevels-1)
    } else {
        encoded_levels += this.encodeNumber(
                this.numLevels-this.computeLevel(absMaxDist)-1)
    }
    for(i=1; i < points.length-1; i++) {
        if(dists[i] != undefined) {
            encoded_levels += this.encodeNumber(
                    this.numLevels-this.computeLevel(dists[i])-1);
        }
    }
    if(this.forceEndpoints) {
        encoded_levels += this.encodeNumber(this.numLevels-1)
    } else {
        encoded_levels += this.encodeNumber(
                this.numLevels-this.computeLevel(absMaxDist)-1)
    }
    return encoded_levels;
}

//This function is very similar to Google's, but I added
//some stuff to deal with the double slash issue.
PolylineEncoder.prototype.encodeNumber = function(num) {
    var encodeString = "";
    var nextValue, finalValue;
    while (num >= 0x20) {
        nextValue = (0x20 | (num & 0x1f)) + 63;
        //  if (nextValue == 92) {
        //    encodeString += (String.fromCharCode(nextValue));
        //  }
        encodeString += (String.fromCharCode(nextValue));
        num >>= 5;
    }
    finalValue = num + 63;
    //if (finalValue == 92) {
    //  encodeString += (String.fromCharCode(finalValue));
    //}
    encodeString += (String.fromCharCode(finalValue));
    return encodeString;
}

//This one is Google's verbatim.
PolylineEncoder.prototype.encodeSignedNumber = function(num) {
    var sgn_num = num << 1;
    if (num < 0) {
        sgn_num = ~(sgn_num);
    }
    return(this.encodeNumber(sgn_num));
}


//The remaining code defines a few convenience utilities.
//PolylineEncoder.latLng
PolylineEncoder.latLng = function(y, x) {
    this.y = y;
    this.x = x;
}
PolylineEncoder.latLng.prototype.lat = function() {
    return this.y;
}
PolylineEncoder.latLng.prototype.lng = function() {
    return this.x;
}

//PolylineEncoder.pointsToLatLngs
PolylineEncoder.pointsToLatLngs = function(points) {
    var i, latLngs;
    latLngs = new Array(0);
    for(i=0; i<points.length; i++) {
        latLngs.push(new PolylineEncoder.latLng(points[i][0], points[i][1]));
    }
    return latLngs;
}

//PolylineEncoder.pointsToGLatLngs
PolylineEncoder.pointsToGLatLngs = function(points) {
    var i, gLatLngs;
    gLatLngs = new Array(0);
    for(i=0; i<points.length; i++) {
        gLatLngs.push(new GLatLng(points[i][0], points[i][1]));
    }
    return gLatLngs;
}

//----------------------------------------- Core Google Maps ----------------------------------------

//google.load("maps", "2.x");

function mapGeocode ( mapContainer ) {
    geomapcont = mapContainer;

    geolatelem = document.getElementById("Latitude_Start").value;
    geolngelem = document.getElementById("Longitude_Start").value;

    if( geolngelem && geolatelem ) {
        loadMap ( new google.maps.LatLng ( geolatelem, geolngelem ) );
    }
    else {

        geostate = document.getElementById( "State" ).value;
        geocountry = document.getElementById( "Country" ).value;

        // try geocode with state and country
        var geocoder = new google.maps.Geocoder();
        var address = geostate + ", " + geocountry;
        geocoder.geocode({'address':address, 'partialmatch':true}, stateCallback);
    }
}

/*
//all functions that has a "2" in it's name is for handling the 'start' and 'end' placemarks.
function mapGeocode2 ( mapContainer, latElem, lngElem, state, country ) {
geomapcont = mapContainer;
geolatelem = latElem;
geolngelem = lngElem;
geocountry = country;
geostate = state;

// try geocode with state and country
var geocoder = new google.maps.ClientGeocoder();
var address = state + ", " + country;
geocoder.getLatLng(address, stateCallback2);
}

function map2Locate ( mapContainer, latElem, lngElem, latElemEnd, lngElemEnd ) {
geomapcont = mapContainer;
geolatelem = latElem;
geolngelem = lngElem;
geolatelemend = latElemEnd;
geolngelemend = lngElemEnd;
geozoomlevel = 5;
load2Map(new google.maps.LatLng(latElem, lngElem), new google.maps.LatLng(latElemEnd, lngElemEnd) );
}
*/

function mapLocate ( mapContainer ) {
    geomapcont = mapContainer;

    geolatelem = document.getElementById("Latitude_Start").value;
    geolngelem = document.getElementById("Longitude_Start").value;

    loadMap ( new google.maps.LatLng ( geolatelem, geolngelem ) );
}

function stateCallback ( point ) {

    if ( point ) {
        loadMap(point);
    } else {
        // try geocode with only country
        var geocoder = new google.maps.Geocoder();
        geocoder.geocode({'address':geocountry, 'partialmatch':true}, countryCallback);
    }
}

function countryCallback ( point ) {
    if ( point ) {
        loadMap(point);
    } else {
        alert("Lattitude and Longitude could not be found for " + geocountry);
    }
}

// for generating kml... i think
function generateMap() {
    map_main = new GMap2( document.getElementById ( 'map_container' ) );
    map_main.addMapType(G_SATELLITE_3D_MAP);

    var mapui = map_main.getDefaultUI();
    mapui.maptypes.physical = false;
    map_main.setUI(mapui);

    var circleColor = new Array("#151B54", "#8D38C9", "#800517", "#3B9C9C", "#4E9258", "#EAC117", "#8A4117" ); 

    var dbColor = Array();
    dbColor['PowerPlants'] = 'FF0000';
    dbColor['Resources'] = '43C6DB';
    dbColor['Transmission'] = 'FFFF00';
    dbColor['Consumers'] = 'EEFF00';

    var symbol = Array();
    symbol['Coal'] = 'C';
    symbol['Gas'] = 'G';
    symbol['Geothermal'] = 'E';
    symbol['Hydro'] = 'H';
    symbol['Nuclear'] = 'N';
    symbol['Oil'] = 'O';
    symbol['Solar_PV'] = 'S';
    symbol['Solar_Thermal'] = 'T';
    symbol['Wind'] = 'W';
    symbol['Waste'] = 'J';
    symbol['Gas_Fields'] = 'G';
    symbol['Oil_Fields'] = 'O';
    symbol['Coal_Mines'] = 'C';
    symbol['Crude_Oil_Refineries'] = 'R';
    symbol['Uranium_Mines'] = 'U';
    symbol['Solar_Potential'] = 'S';
    symbol['Biomass_Potential'] = 'B';
    symbol['Wind_Potential'] = 'W';
    symbol['Water_Resources'] = 'H';
    symbol['CO2_Storage'] = 'X';
    symbol['Coal_Ports'] = 'C';
    symbol['Oil_Pipelines'] = 'O';
    symbol['LNG_Ports'] = 'L';
    symbol['Gas_Pipelines'] = 'G';
    symbol['Rail_Links'] = 'R';
    symbol['Road_Links'] = 'D';
    symbol['Shipping_Lanes'] = 'S';
    symbol['Electric_Power_Grid'] = 'E';
    symbol['Oil_Ports'] = 'P';
    symbol['Industries'] = 'I';

    var NumberOfDB = parseInt( document.getElementById( 'NumberOfDB' ).value );
    for( l=0; l<NumberOfDB; l++) {
        var DBName = document.getElementById("DBName"+l).value;
        var NumberOfTypes = parseInt( document.getElementById( 'NumberOfTypes'+l ).value );
        for( i=0; i<NumberOfTypes; i++ ) {
            if( document.getElementById( 'NumberOfResources'+l+i ) ) {
                var NumberOfResources = parseInt(document.getElementById( 'NumberOfResources'+l+i ).value);
                var TypeName = document.getElementById('TypeName'+l+i).value;
                if(  document.getElementById('Design_Capacity'+i+'0') )
                    var dc_min = parseFloat( document.getElementById('Design_Capacity'+i+'0').value );
                else 
                    var dc_min = 10;
                if( document.getElementById('Design_Capacity'+i+(NumberOfResources-1) ) )
                    var dc_max = parseFloat( document.getElementById('Design_Capacity'+i+(NumberOfResources-1)).value );
                else 
                    var dc_max = dc_min+10000;

                offset = Array();
                polygonPoints = Array();

                offsetValue = 0.005/NumberOfResources;
                offsetColor = 255/NumberOfResources;

                offset[NumberOfResources-1] = 0.005;

                for( j=(NumberOfResources-2); j>=0; j-- ) {
                    if( document.getElementById( 'Design_Capacity'+i+(j+1) ) )
                        Design_Capacity_prev = parseFloat( document.getElementById('Design_Capacity'+i+(j+1)).value );
                    else 
                        Design_Capacity_prev = dc_min + 100;

                    if ( document.getElementById( 'Design_Capacity'+i+j) )
                        Design_Capacity_curr = parseFloat( document.getElementById( 'Design_Capacity'+i+j ).value );
                    else 
                        Design_Capacity_curr = Design_Capacity_prev + 100; 

                    if( Design_Capacity_curr == Design_Capacity_prev ) { 
                        offset[j] = offset[j+1];
                    }
                    else { 
                        offset[j] = offset[j+1] - offsetValue;      
                    }
                    Latitude_Start = parseFloat( document.getElementById( 'Latitude_Start'+i+j ).value );
                    Longitude_Start = parseFloat( document.getElementById( 'Longitude_Start'+i+j ).value );

                    polygonPoints.push( new GLatLng( Latitude_Start, Longitude_Start ) ); 
                }

                if( polygonPoints[0] ) {
                    polygon = new GPolygon( polygonPoints, '#000000', 2, 0.5, '#000000', 0.3 ); 
                    var bounds = polygon.getBounds()
                        var center = bounds.getCenter();
                    var zoom =  map_main.getBoundsZoomLevel( bounds ); 
                    map_main.setCenter( center, zoom );
                }
                else if( document.getElementById( 'Latitude_Start'+i+'0' ).value ) {
                    Latitude_Start = parseFloat( document.getElementById( 'Latitude_Start'+i+'0' ).value );
                    Longitude_Start = parseFloat( document.getElementById( 'Longitude_Start'+i+'0' ).value );
                    point = new google.maps.LatLng(Latitude_Start, Longitude_Start);
                    map_main.setCenter( point, 8 );
                }
                else
                    alert("We currently have no data for this selection(s)");

                for( j=0; j<NumberOfResources; j++ ) {
                    Latitude_Start = parseFloat( document.getElementById( 'Latitude_Start'+i+j ).value );
                    Longitude_Start = parseFloat( document.getElementById( 'Longitude_Start'+i+j ).value );
                    Design_Capacity = parseFloat( document.getElementById( 'Design_Capacity'+i+j ).value );
                    Description_ID = parseFloat( document.getElementById( 'Description_ID'+i+j ).value );
                    Name = document.getElementById( 'Name'+i+j ).value;

                    info = "Name: <b>"+Name+"</b><br/>";
                    info += "Design Capacity: <b>"+Design_Capacity+"</b><br/>";
                    info += "<b>Click <a href='form.php?pid="+Description_ID+"'>here</a> for complete information.</b>";
                    var point = new google.maps.LatLng(Latitude_Start, Longitude_Start);

                    var letter = symbol[TypeName];
                    var bgcolor = dbColor[DBName];

                    var letteredIcon = new GIcon( new GIcon(G_DEFAULT_ICON) );
                    letteredIcon.image = "http://chart.apis.google.com/chart?chst=d_map_pin_letter&chld="+letter+"|"+bgcolor+"|000000";

                    markerOptions = { icon: letteredIcon };
                    marker = new GMarker(point, markerOptions);

                    map_main.addOverlay(marker);

                    addEvent( marker, info );
                }
            }
        }
    }
}

function addEvent( marker, info ) {
    google.maps.Event.addListener(marker, "click", function() {
            marker.openInfoWindowHtml(info);
            });
}




function drawModelCircle( radius, lat, lng, color, opacity, year ){

    var radians = radius/6371000;
    var circlePoints = Array();
    var bounds = new GLatLngBounds();

    with (Math) {
        var lat1 = (PI/180)* lat; // radians
        var lng1 = (PI/180)* lng; // radians

        for (var a = 0 ; a < 361 ; a++ ) {
            var tc = (PI/180)*a;
            var y = asin(sin(lat1)*cos(radians)+cos(lat1)*sin(radians)*cos(tc));
            var dlng = atan2(sin(tc)*sin(radians)*cos(lat1),cos(radians)-sin(lat1)*sin(y));
            var x = ((lng1-dlng+PI) % (2*PI)) - PI ; // MOD function
            var circlepoint = new GLatLng(parseFloat(y*(180/PI)),parseFloat(x*(180/PI)));
            circlePoints.push(circlepoint);
            bounds.extend(circlepoint);
        }

        polygon[++overlaysCount] = new GPolygon(circlePoints, color, 2, opacity, color, opacity);	
        map.addOverlay(polygon[overlaysCount]); 
        map.setZoom( map.getBoundsZoomLevel(bounds));
        addOverlayEntry("Radius(m) = ", color, radius, 'shape', year, 0);

    }
}

function doDrawCircle( radians, lat, lng ){
    var circlePoints = Array();
    with (Math) {
        var lat1 = (PI/180)* lat; // radians
        var lng1 = (PI/180)* lng; // radians

        for (var a = 0 ; a < 361 ; a++ ) {
            var tc = (PI/180)*a;
            var y = asin(sin(lat1)*cos(radians)+cos(lat1)*sin(radians)*cos(tc));
            var dlng = atan2(sin(tc)*sin(radians)*cos(lat1),cos(radians)-sin(lat1)*sin(y));
            var x = ((lng1-dlng+PI) % (2*PI)) - PI ; // MOD function
            var circlepoint = new GLatLng(parseFloat(y*(180/PI)),parseFloat(x*(180/PI)));
            circlePoints.push(circlepoint);
        }

    }
    return circlePoints;
}

var marker1;
//This function is for maps that has only one placemark to display. 
function loadMap ( point ) {

    var options = {
        zoom: geozoomlevel,
        mapTypeId: google.maps.MapTypeId.HYBRID
    };

    map = new google.maps.Map( document.getElementById(geomapcont), options );

    /*
    var mapui = map.getDefaultUI();
    mapui.maptypes.physical = false;
    map.setUI(mapui);
    */
    if( point[0] )
        map.fitBounds(point[0].geometry.viewport);
    else if( point ) 
        map.setCenter(point);

    //map.setCenter(point, geozoomlevel);
    
    var cs = document.getElementById("map_resize_cs").innerHTML;

    google.maps.event.addListener( map, "mousemove", function(event) {
        document.getElementById("map_resize_cs").innerHTML = event.latLng.lat().toFixed(5)+', '+event.latLng.lng().toFixed(5);
    });
    
    google.maps.event.addListener( map, "mouseout", function(point) {
        document.getElementById("map_resize_cs").innerHTML = cs;
    });
    

    var info = "If this is not the exact location of this geo resource,";
    info += "simply drag the marker to new correct position.";


    var letter = String.fromCharCode("A".charCodeAt(0));

    //var letteredIcon = new GIcon( new GIcon(G_DEFAULT_ICON) );
    //letteredIcon.image = "http://www.google.com/mapfiles/marker" + letter + ".png";

    infoWindow = new google.maps.InfoWindow({content: info});
    
    if( point[0] ) {
    marker = new google.maps.Marker( {
        icon: "http://www.google.com/mapfiles/marker" + letter + ".png",
        map: map,
        position: point[0].geometry.location,
        draggable: true,
        html: info
    });
    document.getElementById('Latitude_Start').value = marker.getPosition().lat().toFixed(5);
    document.getElementById('Longitude_Start').value = marker.getPosition().lng().toFixed(5);
    }
    else {

    marker = new google.maps.Marker( {
        icon: "http://www.google.com/mapfiles/marker" + letter + ".png",
        map: map,
        position: point,
        draggable: true,
        html: info
    });

    }


    //markerOptions = { icon: letteredIcon, draggable: true };
    //var marker = new GMarker(point, markerOptions);
    //mgr = new GMarkerManager(map, {trackMarkers: true});

    savedMarker = marker;
    //map.addOverlay(marker);
    //document.getElementById('Latitude_Start').value = document.getElementById('Saved_Latitude_Start').value;
    //document.getElementById('Longitude_Start').value = document.getElementById('Saved_Longitude_Start').value;

    if( document.getElementById("Latitude_End") ) {
        if( document.getElementById("Latitude_End").value ) {
            var latend = document.getElementById("Latitude_End").value;
            var lngend = document.getElementById("Longitude_End").value;
        }
        else {
            var latend = point[0].geometry.location.lat() + 0.05;
            var lngend = point[0].geometry.location.lng() + 0.05;
        }

        var point1 = new google.maps.LatLng(latend.toFixed(5), lngend.toFixed(5));

        var letter = String.fromCharCode("B".charCodeAt(0));
        //var letteredIcon = new GIcon( new GIcon(G_DEFAULT_ICON) );
        //letteredIcon.image = "http://www.google.com/mapfiles/marker" + letter + ".png";

        marker1 = new google.maps.Marker( {
            icon: "http://www.google.com/mapfiles/marker" + letter + ".png",
            map: map,
            position: point1,
            draggable: true,
            html: info
        });

        //markerOptions = { icon: letteredIcon, draggable: true };

        //marker1 = new GMarker ( point1, markerOptions );
        savedMarker2 = marker1;
        //map.addOverlay ( marker1 );
        document.getElementById('Latitude_End').value = marker1.getPosition().lat();
        document.getElementById('Longitude_End').value = marker1.getPosition().lng();

        google.maps.event.addListener(marker1, "click", function() {
                infoWindow.setContent(this.html);
                infoWindow.open(map, this);
                //marker1.openInfoWindowHtml(info);
                });

        google.maps.event.addListener(marker1, "dragstart", function() {
                infoWindow.close();
                //map.closeInfoWindow();
                });

        google.maps.event.addListener(marker1, "dragend", function() {
                document.getElementById('Latitude_End').value = marker1.getPosition().lat();
                document.getElementById('Longitude_End').value = marker1.getPosition().lng();
                });

    }

    google.maps.event.addListener(marker, "click", function() {
            infoWindow.setContent(this.html);
            infoWindow.open(map, this);
            //marker.openInfoWindowHtml(info);
            });

    google.maps.event.addListener(marker, "dragstart", function() {
            infoWindow.close();
            //map.closeInfoWindow();
            });

    google.maps.event.addListener(marker, "dragend", function() {
            document.getElementById("Latitude_Start").value = marker.getPosition().lat();
            document.getElementById("Longitude_Start").value = marker.getPosition().lng();
            });

}

function resizeMap( type ) {
    var w = document.getElementById('Map_Width').value;
    var h = document.getElementById('Map_Height').value;

    document.getElementById('map_container').style.width = w + 'px';
    document.getElementById('map_container').style.height = h + 'px';
    if( type == 'map_main' ) {
        //map_main.checkResize();
        google.maps.event.trigger( map_main, 'resize' );
    }
    else {
        //map.checkResize();
        google.maps.event.trigger( map, 'resize' );
    }

}

function updateMapMarker( dual ) {
        var point = new google.maps.LatLng( document.getElementById('Latitude_Start').value, document.getElementById('Longitude_Start').value );
        savedMarker.setPosition(point);
        savedMarker = marker;
    if( dual ) {
        var point = new google.maps.LatLng( document.getElementById('Latitude_End').value, document.getElementById('Longitude_End').value );
        savedMarker2.setPosition(point);
        savedMarker2 = marker;
    }
}

function restoreMapMarker( dual ) {
        var point = new google.maps.LatLng( document.getElementById('Saved_Latitude_Start').value, document.getElementById('Saved_Longitude_Start').value );
        savedMarker.setPosition(point);

    if (dual) {
        var point = new google.maps.LatLng( document.getElementById('Saved_Latitude_End').value, document.getElementById('Saved_Longitude_End').value );
        savedMarker2.setPostion(point);
    }
    document.getElementById('Latitude_Start').value = document.getElementById('Saved_Latitude_Start').value;
    document.getElementById('Longitude_Start').value = document.getElementById('Saved_Longitude_Start').value;

}

//------------------------------------Polyline and Polygon --------------------------------------------



function getColor(named) {
    return COLORS[(colorIndex_++) % COLORS.length][named ? 0 : 1];
}

function getIcon(color) {
    var icon = new GIcon();
    icon.image = "http://google.com/mapfiles/ms/micons/" + color + ".png";
    icon.iconSize = new GSize(32, 32);
    icon.iconAnchor = new GPoint(15, 32);
    return icon;
}

/* This function writes as HTML,  the details of all the lines drawn. 
*  This function is called after the "Submit" button is clicked. 
*  This HTML representation helps save the points into a table in the db.
*/

function saveOverlays() {
    var j=0;
    var olCount = lineCount + shapeCount;
    for( l=0; l<olCount; l++ ) {
        if( document.getElementById('Overlay_Name_Polyline'+l) ) {
            savePolyline( l );
        }
        else if( document.getElementById('Overlay_Name_Polygon'+l) ) {
            savePolygon( l );
        }
    }
}

function savePolyline ( j ) {
    json = linesJSON[++saveLineCount];

    if( json ) {
    var ColorHTML = '<input type="hidden" name="Color' + j + '" id="Color' + j + '" value="' + json.color + '" />';
    var WeightHTML = '<input type="hidden" name="Weight' + j + '" id="Weight' + j + '" value="' + json.weight + '" />';
    var OpacityHTML = '<input type="hidden" name="Opacity' + j + '" id="Opacity' + j + '" value="' + json.opacity + '" />';
    var PointsHTML = '<input type="hidden" name="Points' + j + '" id="Points' + j + '" value="' + json.points + '" />';
    var LevelsHTML = '<input type="hidden" name="Levels' + j + '" id="Levels' + j + '" value="' + json.levels + '" />';
    var NumLevelsHTML = '<input type="hidden" name="Num_Levels' + j + '" id="Num_Levels' + j + '" value="' + json.numLevels + '" />';
    var ZoomFactorHTML = '<input type="hidden" name="Zoom_Factor' + j + '" id="Zoom_Factor' + j + '" value="' + json.zoomFactor + '" />';
    var OverlayTypeHTML = '<input type="hidden" name="Overlay_Type' + j + '" id="Overlay_Type' + j + '" value="Polyline" />';
    if ( document.getElementById('Overlay_Name_Polyline'+j) )
        var name = document.getElementById('Overlay_Name_Polyline'+j).value;
    else
        var name = '';

    var OverlayNameHTML = '<input type="hidden" name="Overlay_Name' + j + '" id="Overlay_Name' + j + '" value="' + name + '" />';

    var html = ColorHTML + WeightHTML + OpacityHTML + PointsHTML + LevelsHTML + NumLevelsHTML + ZoomFactorHTML + OverlayNameHTML +OverlayTypeHTML ;

    div = document.createElement("div");
    div.setAttribute("id", "LineDesc"+j);
    div.innerHTML = html;
    document.getElementById("Overlay_Span").parentNode.appendChild(div);
    document.getElementById("LinesCount").value = lineCount;
    }
}

function savePolygon( j ) {
    json = shapesJSON[++saveShapeCount];
    if( json ) { 
        var ColorHTML = '<input type="hidden" name="Color' + j + '" id="Color' + j + '" value="' + json.color + '" />';
        var WeightHTML = '<input type="hidden" name="Weight' + j + '" id="Weight' + j + '" value="' + json.weight + '" />';
        var OpacityHTML = '<input type="hidden" name="Opacity' + j + '" id="Opacity' + j + '" value="' + json.opacity + '" />';
        var PointsHTML = '<input type="hidden" name="Points' + j + '" id="Points' + j + '" value="' + json.points + '" />';
        var LevelsHTML = '<input type="hidden" name="Levels' + j + '" id="Levels' + j + '" value="' + json.levels + '" />';
        var NumLevelsHTML = '<input type="hidden" name="Num_Levels' + j + '" id="Num_Levels' + j + '" value="' + json.numLevels + '" />';
        var ZoomFactorHTML = '<input type="hidden" name="Zoom_Factor' + j + '" id="Zoom_Factor' + j + '" value="' + json.zoomFactor + '" />';
        var OverlayTypeHTML = '<input type="hidden" name="Overlay_Type' + j + '" id="Overlay_Type' + j + '" value="Polygon" />';
        if ( document.getElementById('Overlay_Name_Polygon'+j) )
            var name = document.getElementById('Overlay_Name_Polygon'+j).value;
        else
            var name = '';

        var OverlayNameHTML = '<input type="hidden" name="Overlay_Name' + j + '" id="Overlay_Name' + j + '" value="' + name + '" />';

        var html = ColorHTML + WeightHTML + OpacityHTML + PointsHTML + LevelsHTML + NumLevelsHTML + ZoomFactorHTML + OverlayNameHTML + OverlayTypeHTML;

        div = document.createElement("div");
        div.setAttribute("id", "ShapeDesc"+j);
        div.innerHTML = html;
        document.getElementById("Overlay_Span").parentNode.appendChild(div);
        document.getElementById("ShapesCount").value = shapeCount;
    }
}

/* this function encodes the coordinates into a string 
 * and returnes a JSON object with all the necessary information 
 * to save an encoded polyline. Please refer to the encoding 
 * algorithm functions towards the bottom of this file for more 
 * information. 
*/
function encode(poly, color, ovType) {
    var polylineEncoder = new PolylineEncoder();
    /*
    var vertexCount = poly.getVertexCount();
    var vertices = new Array();
    for( i = 0; i < vertexCount; i++ ) { 
        vertices[i] = poly.getVertex(i);
    }
    */
    var vertexCount = poly.getPath().getLength();
    var vertices = new Array();
    for( i=0; i<vertexCount; i++ ) {
        vertices[i] = poly.getPath().getAt(i);
    }
    if(ovType == 'line')
        linesJSON[lineCount] = polylineEncoder.dpEncodeToJSON(vertices, color);
    else if(ovType == 'shape') {
        shapesJSON[shapeCount] = polylineEncoder.dpEncodeToJSON(vertices, color);
    }
}	

/* clears any changes made to the placemarks and restores 
 * already saved version of the placemarks. removes all the lines. 
 */
function startover(type) {
    map.clearOverlays();
    var par = document.getElementById("Overlays");
    for(i=0; i<( lineCount + shapeCount ); i++) {
        if( document.getElementById("LineDetails"+i) ) {
            var child = document.getElementById("LineDetails"+i);
            par.removeChild(child);
        }
        else if( document.getElementById("ShapeDetails"+i) ) { 
            var child = document.getElementById("ShapeDetails"+i);
            par.removeChild(child);
        }
    }
    if(type == "Edit")
        mapLocate(geomapcont);
    else 
        mapGeocode(geomapcont);
    lineCount = 0;
    shapeCount = 0;
    overlaysCount = 0;
    colorIndex_ = 0;
}

function decodeLevels(encodedLevelsString) {
    var decodedLevels = [];

    for (var i = 0; i < encodedLevelsString.length; ++i) {
        var level = encodedLevelsString.charCodeAt(i) - 63;
        decodedLevels.push(level);
    }
    return decodedLevels;
}


// this function is called by form.php to load the saved overlays from the db.
function getOverlays() { 
    polygon = new Array();
    var scnt = document.getElementById('ShapesCount').value;
    var lcnt = document.getElementById('LinesCount').value;
    var cnt = parseInt(scnt) + parseInt(lcnt);

    for(j=0;j<cnt;j++) {
        ++overlaysCount;
        var Color = document.getElementById('Color'+overlaysCount).value;
        var Weight = document.getElementById('Weight'+overlaysCount).value;
        var Opacity = document.getElementById('Opacity'+overlaysCount).value;
        var Points = document.getElementById('Points'+overlaysCount).value;
        var Levels = document.getElementById('Levels'+overlaysCount).value;
        var NumLevels = document.getElementById('Num_Levels'+overlaysCount).value;
        var ZoomFactor = document.getElementById('Zoom_Factor'+overlaysCount).value;
        var Type = document.getElementById('Overlay_Type'+overlaysCount).value;
        var Name = document.getElementById('Overlay_Name_'+Type+overlaysCount).value;

        if( !Color )
            Color = getColor(false);    


        if( Type == 'Polygon' && Points ) { 
            //shapeCount++;
            polygon[overlaysCount] = new google.maps.Polygon({
                        path: google.maps.geometry.encoding.decodePath(Points),
                        levels: decodeLevels(Levels),
                        map: map,
                        fillColor: Color,
                        fillOpacity: 0.4,
                        strokeColor: Color,
                        strokeWeight: Weight
            });


            // this array is used to retrieve the saved overlay by clicking on "restore from saved" button
            // if any changes were made to the overlay, only the "polygon" array is affected

            //savedPolygon[overlaysCount] = polygon[overlaysCount];

            savedPolygon[overlaysCount] = new google.maps.Polygon({
                        path: google.maps.geometry.encoding.decodePath(Points),
                        levels: decodeLevels(Levels),
                        fillColor: Color,
                        fillOpacity: 0.4,
                        strokeColor: Color,
                        strokeWeight: Weight
            });
/*
            savedPolygon[overlaysCount] = new GPolygon.fromEncoded({
                        polylines: 
                            [
                                {
                                color: Color,
                                weight: Weight,
                                points: Points,
                                levels: Levels,
                                zoomFactor: ZoomFactor
                                }
                            ],
                        fill: true,
                        color: Color,
                        opacity: 0.4,
                        outline: true
            });
*/

            area = google.maps.geometry.spherical.computeArea(polygon[overlaysCount].getPath());
            km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup><b>";
            polyType = 'shape';

            addOverlayEntry("Area = ", Color, km, polyType, Name, 0);

            shapeCount++;
            startShapeEvents(polygon[overlaysCount], overlaysCount, Color );
            colorIndex_++;
            //encode( polygon[overlaysCount], Color, 'shape' );
        }
        else if( Points )  {
            polygon[overlaysCount] = new google.maps.Polyline({
                strokeColor: Color,
                strokeWeight: Weight,
                path: google.maps.geometry.encoding.decodePath(Points),
                levels: decodeLevels(Levels),
                map: map
            });

            //savedPolygon[overlaysCount] = polygon[overlaysCount];

            savedPolygon[overlaysCount] = new google.maps.Polyline({
                strokeColor: Color,
                strokeWeight: Weight,
                path: google.maps.geometry.encoding.decodePath(Points),
                levels: decodeLevels(Levels)
            });
/*
            savedPolygon[overlaysCount] = new GPolyline.fromEncoded({
                color: Color,
                weight: Weight,
                points: Points,
                levels: Levels,
                zoomFactor: ZoomFactor,
                numLevels: NumLevels
            });
*/
            len = google.maps.geometry.spherical.computeLength(polygon[overlaysCount].getPath());
            km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
            polyType = 'line';
            
            addOverlayEntry("Length = ", Color, km, polyType, Name, 0);

            lineCount++;
            startLineEvents(polygon[overlaysCount], overlaysCount, Color );
            colorIndex_++;
            encode( polygon[overlaysCount], Color, 'line' );
        }
    }
}

function getAiOverlays() {
    ai_polygon = new Array();
    var scnt = document.getElementById('ai_ShapesCount').value;
    var lcnt = document.getElementById('ai_LinesCount').value;
    var cnt = parseInt(scnt) + parseInt(lcnt);

    for(j=0;j<cnt;j++) {
        ++ai_overlaysCount;

        var Color = AI_Color;
        var Weight = document.getElementById('ai_Weight'+ai_overlaysCount).value;
        var Opacity = document.getElementById('ai_Opacity'+ai_overlaysCount).value;
        var Points = document.getElementById('ai_Points'+ai_overlaysCount).value;
        var Levels = document.getElementById('ai_Levels'+ai_overlaysCount).value;
        var NumLevels = document.getElementById('ai_Num_Levels'+ai_overlaysCount).value;
        var ZoomFactor = document.getElementById('ai_Zoom_Factor'+ai_overlaysCount).value;
        var Type = document.getElementById('ai_Overlay_Type'+ai_overlaysCount).value;
        var Name = document.getElementById('ai_Overlay_Name_'+Type+ai_overlaysCount).value;

        if( !Color )
            Color = getColor(false);    

        if( Type == 'Polygon' && Points ) { 
            //shapeCount++;
            ai_polygon[ai_overlaysCount] = new google.maps.Polygon({
                        path: google.maps.geometry.encoding.decodePath(Points),
                        levels: decodeLevels(Levels),
                        map: map,
                        fillColor: Color,
                        fillOpacity: 0.4,
                        strokeColor: Color,
                        strokeWeight: Weight
            });
/*
            ai_polygon[ai_overlaysCount] = new GPolygon.fromEncoded({
                        polylines: 
                            [
                                {
                                color: Color,
                                weight: Weight,
                                points: Points,
                                levels: Levels,
                                zoomFactor: ZoomFactor
                                }
                            ],
                        fill: true,
                        color: Color,
                        opacity: 0.4,
                        outline: true
            });

            // this array is used to retrieve the saved overlay by clicking on "restore from saved" button
            // if any changes were made to the overlay, only the "polygon" array is affected
            savedPolygon[ai_overlaysCount] = new GPolygon.fromEncoded({
                        polylines: 
                            [
                                {
                                color: Color,
                                weight: Weight,
                                points: Points,
                                levels: Levels,
                                zoomFactor: ZoomFactor
                                }
                            ],
                        fill: true,
                        color: Color,
                        opacity: 0.4,
                        outline: true
            });
*/
            //area = ai_polygon[ai_overlaysCount].getArea();
            area = google.maps.geometry.spherical.computeArea(ai_polygon[ai_overlaysCount].getPath());
            km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup><b>";
            polyType = 'shape';

            addOverlayEntry("Area = ", Color, km, polyType, Name, 1);
            
            //map.addOverlay(ai_polygon[ai_overlaysCount]);

        }
        else if( Points )  {
            ai_polygon[ai_overlaysCount] = new google.maps.Polyline({
                strokeColor: Color,
                strokeWeight: Weight,
                path: google.maps.geometry.encoding.decodePath(Points),
                levels: decodeLevels(Levels),
                map: map
            });
/*
            ai_polygon[ai_overlaysCount] = new GPolyline.fromEncoded({
                color: Color,
                weight: Weight,
                points: Points,
                levels: Levels,
                zoomFactor: ZoomFactor,
                numLevels: NumLevels
            });

            savedPolygon[ai_overlaysCount] = new GPolyline.fromEncoded({
                color: Color,
                weight: Weight,
                points: Points,
                levels: Levels,
                zoomFactor: ZoomFactor,
                numLevels: NumLevels
            });
            */
            //map.addOverlay(ai_polygon[ai_overlaysCount]);

            //len = ai_polygon[ai_overlaysCount].getLength();
            len = google.maps.geometry.spherical.computeLength(ai_polygon[ai_overlaysCount].getPath());
            km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
            polyType = 'line';
           try { 
                var ai_lat_st = document.getElementById("AI"+ai_overlaysCount+"_Lat_Start").value;
                var ai_lng_st = document.getElementById("AI"+ai_overlaysCount+"_Lng_Start").value;
                var ai_lat_ed = document.getElementById("AI"+ai_overlaysCount+"_Lat_End").value;
                var ai_lng_ed = document.getElementById("AI"+ai_overlaysCount+"_Lng_End").value;

                var p = new google.maps.LatLng(ai_lat_st, ai_lng_st);
/*
                var blueIcon = new GIcon(G_DEFAULT_ICON); 
                blueIcon.image = "http://www.google.com/intl/en_us/mapfiles/ms/micons/blue-dot.png";

                markerOptions = { icon: blueIcon };

                marker = new GMarker ( p, markerOptions );
                map.addOverlay ( marker );
                
        var letter = String.fromCharCode("B".charCodeAt(0));
        //var letteredIcon = new GIcon( new GIcon(G_DEFAULT_ICON) );
        //letteredIcon.image = "http://www.google.com/mapfiles/marker" + letter + ".png";
*/
        marker = new google.maps.Marker( {
            icon: "http://www.google.com/intl/en_us/mapfiles/ms/micons/blue-dot.png",
            map: map,
            position: p,
            draggable: false,
        });

                var p = new google.maps.LatLng(ai_lat_ed, ai_lng_ed);

/*
                var blueIcon = new GIcon(G_DEFAULT_ICON); 
                blueIcon.image = "http://www.google.com/intl/en_us/mapfiles/ms/micons/blue-dot.png";
                markerOptions = { icon: blueIcon };

                marker = new GMarker ( p, markerOptions );
                map.addOverlay ( marker );
  */
  marker = new google.maps.Marker( {
            icon: "http://www.google.com/intl/en_us/mapfiles/ms/micons/blue-dot.png",
            map: map,
            position: p,
            draggable: false,
        });
            }
            catch( e ) {}
                addOverlayEntry("Length = ", Color, km, polyType, Name, 1);

        }
    }
}


function startShapeEvents( poly, overlaysCount, Color ) {
    google.maps.event.addListener(poly, "mouseover", function() {
        poly.setEditable(true);
    });


    google.maps.event.addListener(poly, "mouseout", function() {
        poly.setEditable(false);
    });

    google.maps.event.addListener(poly.getPath(), "insert_at", function() {
            var area = google.maps.geometry.spherical.computeArea(poly.getPath());
            var km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup></b>";
            updateArea("Area = ", overlaysCount, km);
            encode(poly, Color, 'shape');
    });

    google.maps.event.addListener(poly.getPath(), "set_at", function() {
            var area = google.maps.geometry.spherical.computeArea(poly.getPath());
            var km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup></b>";
            updateArea("Area = ", overlaysCount, km);
            encode(poly, Color, 'shape');
    });



/*
    google.maps.event.addListener(poly, "click", function(latlng, index) {
            if (typeof index == "number") {
            poly.deleteVertex(index);
            var area = google.maps.geometry.spherical.computeArea(poly.getPath());
            var km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup></b>";
            updateArea("Area = ", overlaysCount, km);
            }
            encode(poly, Color, 'shape');
    });
    // this function is executed when a polygon is modified. 
    // updates the area and encodes the new polygon. 
    google.maps.event.addListener(poly, "mouseup", function() {
            console.log("click");
            var area = google.maps.geometry.spherical.computeArea(poly.getPath());
            console.log(area);
            var km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup></b>";
            updateArea("Area = ", overlaysCount, km);
            encode(poly, Color, 'shape');
    });
    */
}

function startLineEvents(poly, overlaysCount, Color) {
    google.maps.event.addListener(poly, "mouseover", function() {
        poly.setEditable(true);
    });


    google.maps.event.addListener(poly, "mouseout", function() {
        poly.setEditable(false);
    });

    google.maps.event.addListener(poly.getPath(), "insert_at", function() {
                    //var len = poly.getLength();
                    var len = google.maps.geometry.spherical.computeLength(poly.getPath());
                    var km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
                    updateLength("Length = ", overlaysCount, km);
                    encode( poly, Color, 'line' );
    });

    google.maps.event.addListener(poly.getPath(), "set_at", function() {
                    //var len = poly.getLength();
                    var len = google.maps.geometry.spherical.computeLength(poly.getPath());
                    var km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
                    updateLength("Length = ", overlaysCount, km);
                    encode( poly, Color, 'line' );
    });

/*
                poly.enableEditing({onEvent: "mouseover"});
                poly.disableEditing({onEvent: "mouseout"});

                // this function is executed when a vertex is clicked. 
                // Gets the index of the vertex, deletes it, updates the length of the line and encodes the new line. 
                GEvent.addListener(poly, "click", function(latlng, index) {
                    if (typeof index == "number") {
                        poly.deleteVertex(index);
                        var len = poly.getLength();
                        var km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
                        updateLength("Length = ", overlaysCount, km);
                    }
                    encode(poly, Color, 'line');
                });

                // this function is executed when the line is modified. 
                // updates the length of the line and encodes the new line. 
                GEvent.addListener(poly, "lineupdated", function() {
                    var len = poly.getLength();
                    var km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
                    updateLength("Length = ", overlaysCount, km);
                    encode( poly, Color, 'line' );
                });
*/
}

// These two functions starts drawing new overlays
function startLine() {	
    polyType = 'line';
    document.getElementById("line_b").className="selected";
    var color = getColor(false);
    //polygon[++overlaysCount] = new google.maps.Polyline();
    ++lineCount;

    

    startDrawing("Length = ", color, 'line', overlaysCount);
}

function startShape() {
    polyType = 'shape';
    document.getElementById("shape_b").className="selected";
    var color = getColor(false);
    //polygon[++overlaysCount] = new google.maps.Polygon();
    ++shapeCount;

    startDrawing("Area = ", color, 'shape', overlaysCount);
}

//This function hides/shows a particular overlay, when it is checked or unchecked. 
function toggleOverlay(chk) {
    for(i=0; i<=overlaysCount; i++) {
        if(chk.checked == false && chk.value == i){
            //map.removeOverlay(polygon[i]); 
            polygon[i].setMap(null);
        }
        else if(chk.checked == false && chk.value == "AI"+i) {
            //map.removeOverlay(ai_polygon[i]);
            ai_polygon[i].setMap(null);
        }
        else if(chk.checked == true && chk.value == i) {
            //map.addOverlay(polygon[i]);
            polygon[i].setMap(map);
        }
        else if(chk.checked == true && chk.value == "AI"+i) {
            //map.addOverlay(ai_polygon[i]);
            ai_polygon[i].setMap(map);
        }
    }
}

function deleteOverlay(id, value) {
    var ans = confirm( "Are you sure you want to delete this overlay (Use the checkbox to show/hide)?" );
    if ( !ans ) {
        return;
    }
    if (id == 'checkLine' ) {
        //map.removeOverlay( polygon[value] );
        polygon[value].setMap(null);

        // the hidden information (for saving) about this overlays are deleted
        if( document.getElementById("LineDesc"+value) ) {
            var par = document.getElementById("Overlay_Span");
            var child = document.getElementById("LineDesc"+value);
            par.removeChild(child);
        }

        // the line details that are displayed on the page is removed
        var par = document.getElementById("Overlays");
        var child = document.getElementById("LineDetails"+value);
        par.removeChild(child);
        --lineCount;
        --overlaysCount;
        document.getElementById("LinesCount").value = lineCount;
        --colorIndex_;
    }
    else if (id == 'checkShape' ) {
        //map.removeOverlay( polygon[value] );
        polygon[value].setMap(null);

        // the hidden information (for saving) about this overlays are deleted
        if( document.getElementById("ShapeDesc"+value) ) {
            var par = document.getElementById("Overlay_Span");
            var child = document.getElementById("ShapeDesc"+value);
            par.removeChild(child);
        }

        // the shape details that are displayed on the page is removed
        var par = document.getElementById("Overlays");
        var child = document.getElementById("ShapeDetails"+value);
        par.removeChild(child);
        --shapeCount;
        --overlaysCount;
        document.getElementById("ShapeCount").value = shapeCount;
        --colorIndex_;
    }
}

// restores any changes on individual overlay to the version that was stored in the db.
function restoreOverlay(id, value) {
    // savedPolygon array contains the db version of the overlay
    if( savedPolygon[value] ) {
        var Type = document.getElementById('Overlay_Type'+value).value;
        var Name = document.getElementById('Overlay_Name_'+Type+value).value;
        if( id == 'checkShape' ) { 
            //map.removeOverlay( polygon[value] );
            polygon[value].setMap(null);

            var par = document.getElementById("Overlays");
            var child = document.getElementById("ShapeDetails"+value);
            par.removeChild(child);


            //area = savedPolygon[value].getArea();
            area = google.maps.geometry.spherical.computeArea(savedPolygon[value].getPath());
            km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup><b>";
            polyType = 'shape';
            var Color = savedPolygon[value].fillColor;
            addOverlayEntry("Area = ", Color, km, polyType, Name, 0);
            //map.addOverlay(savedPolygon[value]);
            savedPolygon[value].setMap(map);
            startShapeEvents(savedPolygon[value], value, Color );

/*
            savedPolygon[value].enableEditing({onEvent: "mouseover"});
            savedPolygon[value].disableEditing({onEvent: "mouseout"});

            GEvent.addListener(polygon[overlaysCount], "click", function(latlng, index) {
                    if (typeof index == "number") {
                        polygon[overlaysCount].deleteVertex(index);
                        var area = polygon[overlaysCount].getArea();
                        var km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup></b>";
                        updateArea("Area = ", overlaysCount, km);
                    }
                    encode(polygon[overlaysCount], color, 'shape');
            });

            GEvent.addListener(polygon[overlaysCount], "lineupdated", function() {
                    var area = polygon[overlaysCount].getArea();
                    var km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup></b>";
                    updateArea("Area = ", overlaysCount, km);
                    encode(polygon[overlaysCount], Color, 'shape');
                    });
  */
            encode( savedPolygon[value], Color, 'shape' );
        }
        else if( id == 'checkLine' )  {
            //map.removeOverlay( polygon[value] );
            polygon[value].setMap(null);

            var par = document.getElementById("Overlays");
            var child = document.getElementById("LineDetails"+value);
            par.removeChild(child);

            savedPolygon[value].setMap(map);

            //len = savedPolygon[value].getLength();
            len = google.maps.geometry.spherical.computeLength(savedPolygon[value].getPath());
            km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
            polyType = 'line';
            var Color = savedPolygon[value].fillColor;
            addOverlayEntry("Length = ", Color, km, polyType, Name, 0);
            startLineEvents(savedPolygon[value], value, Color);

/*
            polygon[overlaysCount].enableEditing({onEvent: "mouseover"});
            polygon[overlaysCount].disableEditing({onEvent: "mouseout"});

            GEvent.addListener(polygon[overlaysCount], "click", function(latlng, index) {
                    if (typeof index == "number") {
                        polygon[overlaysCount].deleteVertex(index);
                        var len = polygon[overlaysCount].getLength();
                        var km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
                        updateLength("Length = ", overlaysCount, km);
                    }
                    encode(polygon[overlaysCount], color, 'line');
            });

            GEvent.addListener(polygon[overlaysCount], "lineupdated", function() {
                    var len = polygon[overlaysCount].getLength();
                    var km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
                    updateLength("Length = ", overlaysCount, km);
                    encode( polygon[overlaysCount], Color, 'line' );
            });
*/
            colorIndex_++;
            encode( savedPolygon[value], Color, 'line' );
        }
        polygon[value] = savedPolygon[value];
    }
}

//After every overlay is drawn, this function is called to display the details of that overlay. 
function addOverlayEntry(name, color, len, polyType, Name, is_AI) {
    if(polyType == 'line') {
        var par = document.getElementById("Overlays");
        currentRow_ = document.createElement("tr");
        currentRow_.setAttribute("id", "LineDetails"+overlaysCount);

        var checkCell = document.createElement("td");
        if( is_AI == 0 ) {
            var text = "<input type='checkbox' id='checkLine' name='checkLine' value='"+overlaysCount+"' checked='checked' title='Hide/Show this line' onclick='toggleOverlay(this);' />";
        }
        else {
            var text = "<input type='checkbox' id='checkLine' name='checkLine' value='AI"+overlaysCount+"' checked='checked' title='Hide/Show this line' onclick='toggleOverlay(this);' disabled/>";
        }

        checkCell.innerHTML = text;
        currentRow_.appendChild(checkCell);

        var colorCell = document.createElement("td");
        currentRow_.appendChild(colorCell);
        colorCell.style.backgroundColor = color;
        colorCell.style.width = "1em";

        var nameCell = document.createElement("td");
        nameCell.setAttribute("id", "LineName"+overlaysCount);
        currentRow_.appendChild(nameCell);
        nameCell.innerHTML = name + len;

        var nameTd = document.createElement("td");
        currentRow_.appendChild(nameTd);
        if( is_AI == 0 ) {
            nameTd.innerHTML = "Description: ";
            var nameText = document.createElement("input");
            nameText.setAttribute("id", "Overlay_Name_Polyline"+overlaysCount);
            nameText.setAttribute("name", "Overlay_Name_Polyline"+overlaysCount);
            nameText.setAttribute("value", Name);
            nameText.setAttribute("type", "text");
            nameText.setAttribute("size", "15");
            nameTd.appendChild(nameText);
        }
        else {
            nameTd.setAttribute("id", "AI_Overlay_Name_Polyline");
            currentRow_.appendChild(nameTd);
            nameTd.innerHTML = "<b>Associated Infrastructure: </b>"+Name;
        }

        if( is_AI == 0 ) {
            var deleteOverlay = document.createElement("td");
            var button = "<input type='button' id='restoreOverlay"+overlaysCount+"' name='restoreOverlay"+overlaysCount+"' value='Restore from saved' onclick='restoreOverlay(\"checkLine\", \""+overlaysCount+"\")' />";
            button += "<input type='button' id='deleteOverlay"+overlaysCount+"' name='deleteOverlay"+overlaysCount+"' value='Delete this Overlay' onclick='deleteOverlay(\"checkLine\", \""+overlaysCount+"\")' />";
            deleteOverlay.innerHTML = button;
            currentRow_.appendChild(deleteOverlay);
        }
        par.appendChild(currentRow_);
        //This is for the style of the polyline/polygon icon. 
        document.getElementById("line_b").className="";
    } else if (polyType == 'shape') {
        var par = document.getElementById("Overlays");
        currentRow_ = document.createElement("tr");
        currentRow_.setAttribute("id", "ShapeDetails"+overlaysCount);

        var checkCell = document.createElement("td");
        if( is_AI == 0 )
            var text = "<input type='checkbox' id='checkShape' name='checkShape' value='"+overlaysCount+"' checked='checked' title='Hide/Show this polygon' onclick='toggleOverlay(this);' />";
        else 
            var text = "<input type='checkbox' id='checkShape' name='checkShape' value='AI"+overlaysCount+"' checked='checked' title='Hide/Show this polygon' onclick='toggleOverlay(this);' disabled/>";
        checkCell.innerHTML = text;
        currentRow_.appendChild(checkCell);

        var colorCell = document.createElement("td");
        currentRow_.appendChild(colorCell);
        colorCell.style.backgroundColor = color;
        colorCell.style.width = "1em";

        var nameCell = document.createElement("td");
        nameCell.setAttribute("id", "ShapeName"+overlaysCount);
        currentRow_.appendChild(nameCell);
        nameCell.innerHTML = name + len;

        var nameTd = document.createElement("td");
        currentRow_.appendChild(nameTd);
        if( is_AI == 0 ) {
            nameTd.innerHTML = "Description: ";
            var nameText = document.createElement("input");
            nameText.setAttribute("id", "Overlay_Name_Polygon"+overlaysCount);
            nameText.setAttribute("name", "Overlay_Name_Polygon"+overlaysCount);
            nameText.setAttribute("value", Name);
            nameText.setAttribute("type", "text");
            nameText.setAttribute("size", "15");
            nameTd.appendChild(nameText);
        } 
        else {
            nameTd.setAttribute("id", "Overlay_Name_Polygon"+overlaysCount);
            currentRow_.appendChild(nameTd);
            nameTd.innerHTML = "<b>Associated Infrastructure: </b>"+Name;
        }

        if( is_AI == 0 ) {
            var deleteOverlay = document.createElement("td");
            var button = "<input type='button' id='restoreOverlay"+overlaysCount+"' name='restoreOverlay"+overlaysCount+"' value='Restore from saved' onclick='restoreOverlay(\"checkShape\", \""+overlaysCount+"\")' />";
            button += "<input type='button' id='deleteOverlay"+overlaysCount+"' name='deleteOverlay"+overlaysCount+"' value='Delete this Overlay' onclick='deleteOverlay(\"checkShape\", \""+overlaysCount+"\")' />";
            deleteOverlay.innerHTML = button;
            currentRow_.appendChild(deleteOverlay);
        }
        par.appendChild(currentRow_);

        //This is for the style of the polyline/polygon icon. 
        document.getElementById("shape_b").className="";
    }
}

//Draws polyline/polygon
function startDrawing(name, color, polyType, ovCount) {
    //map.addOverlay(poly);
    //poly.setMap(map);
    var drawingManager;

    if( polyType == 'line' ) {
        drawingManager = new google.maps.drawing.DrawingManager({
            drawingMode: google.maps.drawing.OverlayType.POLYLINE,
            drawingControl: false,
            map: map,
            polylineOptions: {
                editable: true,
                fillColor: color,
                strokeColor: color,
                fillOpacity: 0.4
            },
        });
    }
    else if( polyType == 'shape' ) {
        drawingManager = new google.maps.drawing.DrawingManager({
            drawingMode: google.maps.drawing.OverlayType.POLYGON,
            drawingControl: false,
            map: map,
            polygonOptions: {
                editable: true,
                fillColor: color,
                strokeColor: color,
                fillOpacity: 0.4
            },
        });
    }



    //poly.enableDrawing(options);
    //poly.enableEditing({onEvent: "mouseover"});
    //poly.disableEditing({onEvent: "mouseout"});

    //This function is executed after the last point is drawn. 
    google.maps.event.addListener(drawingManager, "overlaycomplete", function(event) {
            //event.overlay.setEditable(false);
            polygon[++overlaysCount] = event.overlay;
            if(polyType == 'line') {
                //var len = poly.getLength();
                var len = google.maps.geometry.spherical.computeLength(event.overlay.getPath());
                var km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
                startLineEvents(event.overlay, overlaysCount, color );
            } else if (polyType == 'shape') {
                var area = google.maps.geometry.spherical.computeArea(event.overlay.getPath());
                //var area = poly.getArea();
                var km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup></b>";
                startShapeEvents(event.overlay, overlaysCount, color );
            }

            addOverlayEntry(name, color, km, polyType, '', 0);
            encode(event.overlay, color, polyType);
            drawingManager.setMap(null);

/*
            google.maps.event.addListener(poly, "click", function(latlng, index) {
                if (typeof index == "number") {
                    poly.deleteVertex(index);
                    if(polyType == 'line') {
                        var len = poly.getLength();
                        var km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
                        updateLength(name, ovCount, km);
                    } else if (polyType == 'shape') {
                        var area = poly.getArea();
                        var km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup></b>";
                        updateArea(name, ovCount, km);
                    }
                    encode(poly, color, polyType);
                }
            });

            google.maps.event.addListener(poly, "lineupdated", function() {
                    if(polyType == 'line') {
                    var len = poly.getLength();
                    var km = "<b>" + (Math.round(len / 10) / 100) + " km </b>";
                    updateLength(name, ovCount, km);
                    } else if (polyType == 'shape') {
                    var area = poly.getArea();
                    var km = "<b>" + (Math.round(area / 10000) / 100) + " km<sup>2</sup></b>";
                    updateArea(name, ovCount, km);
                    }
                    encode(poly, color, polyType);
            });
*/
    });
}

//Updates the area of a polygon if it's modified. Called from the event listener function. 
function updateArea(name, shapeno, km) {
    cont = document.getElementById("ShapeName"+shapeno);
    cont.innerHTML = "";
    cont.innerHTML = name + km;
}

//Updates the length of a line if it's modified. Called from the event listener function. 
function updateLength(name, lineno, km) {
    cont = document.getElementById("LineName"+lineno);
    cont.innerHTML = "";
    cont.innerHTML = name + km;
}

function placeMarker() {
    select("placemark_b");
    var listener = GEvent.addListener(map, "click", function(overlay, latlng) {
            if (latlng) {
                select("hand_b");
                GEvent.removeListener(listener);
                var color = getColor(true);
                var marker = new GMarker(latlng, {icon: getIcon(color), draggable: true});
                map.addOverlay(marker);
                var cells = addFeatureEntry("Placemark " + (++markerCounter_), color);
                updateMarker(marker, cells);

                GEvent.addListener(marker, "dragend", function() {
                    updateMarker(marker, cells);
                });

                GEvent.addListener(marker, "click", function() {
                    updateMarker(marker, cells, true);
                });
            }
    });
}

function updateMarker(marker, cells, opt_changeColor) {
    if (opt_changeColor) {
        var color = getColor(true);
        marker.setImage(getIcon(color).image);
        cells.color.style.backgroundColor = color;
    }
    var latlng = marker.getPoint();
    cells.desc.innerHTML = "(" + Math.round(latlng.y * 100) / 100 + ", " +
        Math.round(latlng.x * 100) / 100 + ")";
}
